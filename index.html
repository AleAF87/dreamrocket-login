<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Leitor Móvel - Gabarito 4×20</title>
<style>
  :root{--bg:#f7fafc;--accent:#0b63d6;--muted:#6b7280}
  body{margin:0;font-family:system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:#111;padding:14px}
  .wrap{max-width:900px;margin:0 auto}
  h1{font-size:18px;margin:6px 0}
  .btn{display:block;width:100%;padding:16px;border-radius:12px;border:0;margin:10px 0;font-size:18px;background:var(--accent);color:#fff;cursor:pointer}
  .btn.secondary{background:#374151}
  .btn.warn{background:#f59e0b}
  .small{font-size:13px;color:var(--muted)}
  #video{width:100%;border-radius:10px;border:1px solid #ddd}
  #previewImg{width:100%;border-radius:10px;border:1px solid #ddd;margin-top:8px}
  #overlay{position:absolute;left:0;top:0;pointer-events:none}
  #imgWrap{position:relative;display:block;margin-top:8px}
  .resultsCard{background:#fff;padding:12px;border-radius:10px;margin-top:12px;box-shadow:0 1px 4px rgba(0,0,0,0.06)}
  pre{white-space:pre-wrap;background:#111;color:#fff;padding:8px;border-radius:6px;overflow:auto}
  label{display:block;margin-top:8px}
  input[type=file]{width:100%}
</style>
</head>
<body>
<div class="wrap">
  <h1>Leitor Móvel de Gabarito — 4×20 (A–D)</h1>
  <div class="small">Use seu celular: enquadre o gabarito (uma ficha por foto). Recomendo boa iluminação e foco.</div>

  <button id="startCam" class="btn">Abrir Câmera (facing environment)</button>
  <button id="captureBtn" class="btn secondary">Capturar Foto</button>

  <label class="small">ou envie uma imagem (PNG/JPG):</label>
  <input id="fileInput" type="file" accept="image/*" />

  <div id="imgWrap">
    <video id="video" autoplay playsinline style="display:none"></video>
    <img id="previewImg" src="" alt="" />
    <canvas id="overlay" style="position:absolute;top:0;left:0;"></canvas>
  </div>

  <button id="autoDetect" class="btn warn">Detectar automaticamente o contorno (experimental)</button>
  <button id="processBtn" class="btn">Processar (usar 4 cantos definidos)</button>

  <div class="small" id="instr" style="margin-top:8px">
    Instruções:
    <ol>
      <li>Abra a câmera e capture a foto (ou faça upload).</li>
      <li>Após a imagem aparecer, toque 4 vezes nos cantos do gabarito (sentido qualquer) — apenas 4 toques — ou clique em "Detectar automaticamente".</li>
      <li>Ao processar, cole a chave JSON (ex: [0,1,2,3,...] com 20 valores; 0=A,1=B...).</li>
    </ol>
  </div>

  <div id="resultsArea"></div>
  <div id="log" class="small" style="margin-top:8px"></div>
</div>

<!-- OpenCV.js CDN -->
<script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady();"></script>

<script>
let cvReady=false;
function onOpenCvReady(){ cv['onRuntimeInitialized']=()=>{ cvReady=true; console.log('OpenCV ready'); } }

const startCam = document.getElementById('startCam');
const captureBtn = document.getElementById('captureBtn');
const fileInput = document.getElementById('fileInput');
const video = document.getElementById('video');
const previewImg = document.getElementById('previewImg');
const overlay = document.getElementById('overlay');
const autoDetect = document.getElementById('autoDetect');
const processBtn = document.getElementById('processBtn');
const resultsArea = document.getElementById('resultsArea');
const logEl = document.getElementById('log');

let stream=null;
let clicks = []; // will store 4 points
let imgNaturalW=0, imgNaturalH=0;

function log(msg){ logEl.innerText = msg; }

// Start camera (mobile back)
startCam.onclick = async ()=>{
  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return alert('Navegador sem suporte a câmera');
  try {
    stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}, audio:false});
    video.srcObject = stream;
    await video.play();
    // capture first frame to preview so user can click
    captureFrame();
    video.style.display = 'none'; // we only use frame capture
    log('Câmera aberta — capture a foto.');
  } catch(e){ alert('Erro ao abrir câmera: '+e.message); }
};

// Capture frame from camera and show image
captureBtn.onclick = ()=> captureFrame();

function captureFrame(){
  if (!stream) return alert('Abra a câmera primeiro ou faça upload de uma imagem');
  const track = stream.getVideoTracks()[0];
  const settings = track.getSettings();
  const w = settings.width || video.videoWidth;
  const h = settings.height || video.videoHeight;
  // draw into canvas then to dataURL
  let c = document.createElement('canvas'); c.width = w; c.height = h;
  let ctx = c.getContext('2d'); ctx.drawImage(video,0,0,w,h);
  let dataUrl = c.toDataURL('image/jpeg', 0.95);
  loadImageFromDataUrl(dataUrl);
}

// File upload
fileInput.onchange = (e)=>{
  const f = e.target.files[0];
  if (!f) return;
  if (f.type === 'application/pdf') { alert('Envie uma imagem (PNG/JPG) da ficha recortada.'); return; }
  const reader = new FileReader();
  reader.onload = ()=> loadImageFromDataUrl(reader.result);
  reader.readAsDataURL(f);
};

function loadImageFromDataUrl(dataUrl){
  previewImg.src = dataUrl;
  previewImg.onload = ()=>{
    imgNaturalW = previewImg.naturalWidth;
    imgNaturalH = previewImg.naturalHeight;
    overlay.width = previewImg.clientWidth;
    overlay.height = previewImg.clientHeight;
    overlay.style.left = previewImg.offsetLeft + 'px';
    overlay.style.top = previewImg.offsetTop + 'px';
    clicks = [];
    drawOverlay();
    log('Imagem carregada. Toque 4 cantos do gabarito na imagem.');
  };
}

// map clicks to natural image coordinates
previewImg.addEventListener('click', (ev)=>{
  if (!previewImg.src) return;
  const rect = previewImg.getBoundingClientRect();
  let x = ev.clientX - rect.left;
  let y = ev.clientY - rect.top;
  let nx = x * (previewImg.naturalWidth / rect.width);
  let ny = y * (previewImg.naturalHeight / rect.height);
  if (clicks.length >= 4) { clicks = []; } // reset if user wants to re-click
  clicks.push({x:nx,y:ny});
  drawOverlay();
  if (clicks.length === 4) log('4 cantos recebidos. Agora clique em PROCESSAR.');
});

// draw overlay dots & polygon
function drawOverlay(){
  const ctx = overlay.getContext('2d');
  overlay.width = previewImg.clientWidth;
  overlay.height = previewImg.clientHeight;
  ctx.clearRect(0,0,overlay.width,overlay.height);
  if (!previewImg.src) return;
  const sx = previewImg.clientWidth / previewImg.naturalWidth;
  const sy = previewImg.clientHeight / previewImg.naturalHeight;
  ctx.fillStyle = '#111';
  ctx.strokeStyle = '#16a34a';
  ctx.lineWidth = 3;
  for (let i=0;i<clicks.length;i++){
    let p = clicks[i];
    let cx = p.x * sx, cy = p.y * sy;
    ctx.beginPath(); ctx.arc(cx,cy,6,0,Math.PI*2); ctx.fill();
  }
  if (clicks.length === 4){
    ctx.beginPath();
    for (let i=0;i<4;i++){
      let p = clicks[i]; let cx = p.x * sx, cy = p.y * sy;
      if (i===0) ctx.moveTo(cx,cy); else ctx.lineTo(cx,cy);
    }
    ctx.closePath(); ctx.stroke();
  }
}

// automatic detection: try to find largest quadrilateral contour (document-like)
autoDetect.onclick = ()=>{
  if (!previewImg.src) return alert('Carregue a imagem primeiro');
  if (!cvReady) return alert('OpenCV ainda inicializando — aguarde alguns segundos e tente de novo.');
  try {
    let img = cv.imread(previewImg);
    let gray = new cv.Mat(); cv.cvtColor(img, gray, cv.COLOR_RGBA2GRAY, 0);
    let blur = new cv.Mat(); cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0);
    let edged = new cv.Mat(); cv.Canny(blur, edged, 50, 150);
    let contours = new cv.MatVector(), hier = new cv.Mat();
    cv.findContours(edged, contours, hier, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);
    // find largest approx poly with 4 points
    let best = null, bestArea = 0;
    for (let i=0;i<contours.size();i++){
      let c = contours.get(i);
      let area = cv.contourArea(c);
      if (area < 1000) { c.delete(); continue; }
      let peri = cv.arcLength(c, true);
      let approx = new cv.Mat();
      cv.approxPolyDP(c, approx, 0.02 * peri, true);
      if (approx.rows === 4 && area > bestArea){
        bestArea = area; best = approx.clone();
      }
      approx.delete(); c.delete();
    }
    if (!best) {
      alert('Não encontrou contorno quadrilateral com confiança. Tente o método manual (toque 4 cantos).');
      img.delete(); gray.delete(); blur.delete(); edged.delete(); contours.delete(); hier.delete();
      return;
    }
    // extract 4 points
    let pts = [];
    for (let i=0;i<4;i++){
      let px = best.intPtr(i,0)[0], py = best.intPtr(i,0)[1];
      pts.push({x:px,y:py});
    }
    clicks = pts;
    drawOverlay();
    alert('Contorno detectado. Reveja os pontos e clique Processar.');
    img.delete(); gray.delete(); blur.delete(); edged.delete(); contours.delete(); hier.delete(); best.delete();
  } catch(err){
    alert('Erro na detecção automática: '+err);
  }
};

// main processing
processBtn.onclick = ()=>{
  if (!previewImg.src) return alert('Carregue ou capture a imagem antes');
  if (clicks.length !== 4) return alert('Defina 4 cantos do gabarito (clicando na imagem) ou use detecção automática.');
  if (!cvReady) return alert('OpenCV ainda inicializando — aguarde e tente de novo.');
  // ask for key
  let raw = prompt('Cole a chave JSON com 20 valores (ex: [0,1,2,3,...]) — 0=A,1=B,2=C,3=D. Se cancelar, uso chave vazia (todas A).');
  let key = null;
  if (raw){
    try { key = JSON.parse(raw); if (!Array.isArray(key) || key.length < 20) { alert('Chave inválida ou com menos de 20 itens. Usarei chave vazia.'); key = null; } }
    catch(e){ alert('Chave inválida. Usarei chave vazia.'); key = null; }
  }
  if (!key) key = new Array(20).fill(0);
  try {
    let res = processSingleGabarito(clicks, key);
    displayResult(res);
  } catch(e){ alert('Erro no processamento: '+e); console.error(e); }
};

// processSingleGabarito: warp and detect 4x20
function processSingleGabarito(pts, key){
  // order points to tl,tr,br,bl
  let cx = pts.reduce((s,p)=>s+p.x,0)/4, cy = pts.reduce((s,p)=>s+p.y,0)/4;
  let tl, tr, br, bl;
  pts.forEach(p=>{
    if (p.x < cx && p.y < cy) tl = p;
    else if (p.x > cx && p.y < cy) tr = p;
    else if (p.x > cx && p.y > cy) br = p;
    else if (p.x < cx && p.y > cy) bl = p;
  });
  if (!tl || !tr || !br || !bl) { [tl,tr,br,bl] = pts; } // fallback

  // determine destination size: A4 usable width scaled - choose width 1200px, height ~150px (4cm)
  const dstW = 1200;
  const dstH = Math.round(dstW * 0.12); // ~144px height for 4cm proportion
  let srcMat = cv.imread(previewImg);
  let srcTri = cv.matFromArray(4,1,cv.CV_32FC2,[tl.x,tl.y, tr.x,tr.y, br.x,br.y, bl.x,bl.y]);
  let dstTri = cv.matFromArray(4,1,cv.CV_32FC2,[0,0, dstW-1,0, dstW-1,dstH-1, 0,dstH-1]);
  let M = cv.getPerspectiveTransform(srcTri, dstTri);
  let warped = new cv.Mat();
  cv.warpPerspective(srcMat, warped, M, new cv.Size(dstW, dstH));

  // preprocessing tuned for 3mm bubbles (small)
  let gray = new cv.Mat(); cv.cvtColor(warped, gray, cv.COLOR_RGBA2GRAY, 0);
  let blur = new cv.Mat(); cv.GaussianBlur(gray, blur, new cv.Size(3,3), 0);
  let th = new cv.Mat(); cv.adaptiveThreshold(blur, th, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 21, 7);

  // find contours
  let cnts = new cv.MatVector(), hier = new cv.Mat();
  cv.findContours(th, cnts, hier, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
  let candidates = [];
  for (let i=0;i<cnts.size();i++){
    let c = cnts.get(i);
    let area = cv.contourArea(c);
    if (area < 20 || area > 4000) { c.delete(); continue; }
    let rect = cv.boundingRect(c);
    let peri = cv.arcLength(c, true);
    if (peri === 0) { c.delete(); continue; }
    let circularity = 4*Math.PI*area/(peri*peri);
    if (circularity > 0.30) {
      candidates.push({c:c, area:area, rect:rect, cx:rect.x+rect.width/2, cy:rect.y+rect.height/2});
    } else { c.delete(); }
  }
  // fallback: if too few, relax circularity
  if (candidates.length < 30){
    for (let i=0;i<cnts.size();i++){
      let c = cnts.get(i);
      let area = cv.contourArea(c);
      if (area < 20 || area > 5000) continue;
      let rect = cv.boundingRect(c);
      let peri = cv.arcLength(c, true);
      if (peri === 0) continue;
      let circularity = 4*Math.PI*area/(peri*peri);
      if (circularity > 0.22 && !candidates.find(x=>x.rect.x===rect.x && x.rect.y===rect.y)){
        candidates.push({c:c, area:area, rect:rect, cx:rect.x+rect.width/2, cy:rect.y+rect.height/2});
      }
    }
  }

  // sort and cluster into 4 rows
  candidates.sort((a,b)=>a.cy - b.cy || a.cx - b.cx);
  let rows = [];
  let yTol = Math.max(6, Math.round(dstH/60));
  candidates.forEach(pt=>{
    let placed=false;
    for (let r of rows){
      if (Math.abs(pt.cy - r.avgY) < yTol){ r.items.push(pt); r.avgY = (r.avgY*(r.items.length-1)+pt.cy)/r.items.length; placed=true; break; }
    }
    if (!placed) rows.push({avgY:pt.cy, items:[pt]});
  });
  // reduce to 4 rows
  while (rows.length > 4){
    rows.sort((a,b)=>a.avgY - b.avgY);
    let minGap=Infinity, idx=0;
    for (let i=0;i<rows.length-1;i++){
      let gap = Math.abs(rows[i+1].avgY - rows[i].avgY);
      if (gap < minGap){ minGap = gap; idx = i; }
    }
    let merged = {avgY:(rows[idx].avgY*rows[idx].items.length + rows[idx+1].avgY*rows[idx+1].items.length)/(rows[idx].items.length+rows[idx+1].items.length), items: rows[idx].items.concat(rows[idx+1].items)};
    rows.splice(idx,2,merged);
  }
  rows.sort((a,b)=>a.avgY - b.avgY);

  // for each row get 20 columns
  let answers = []; // will be 4 x 20 densities
  for (let r=0;r<4;r++){
    let row = rows[r] || {items:[]};
    row.items.sort((a,b)=>a.cx - b.cx);
    let items = row.items;
    if (items.length > 20){
      let step = items.length / 20; let sel=[];
      for (let k=0;k<20;k++) sel.push(items[Math.floor(k*step)]);
      items = sel;
    } else if (items.length < 20){
      while (items.length < 20) items.push(null);
    }
    let dens = [];
    for (let cidx=0;cidx<20;cidx++){
      let it = items[cidx];
      if (!it) { dens.push(0); continue; }
      let rx = Math.max(0, it.rect.x-2), ry = Math.max(0, it.rect.y-2);
      let rw = Math.min(th.cols - rx, it.rect.width+4), rh = Math.min(th.rows - ry, it.rect.height+4);
      if (rw <= 0 || rh <= 0) { dens.push(0); continue; }
      let roi = th.roi(new cv.Rect(rx,ry,rw,rh));
      let nonZero = cv.countNonZero(roi);
      let d = nonZero / (rw*rh);
      dens.push(d);
      roi.delete();
    }
    answers.push(dens);
  }

  // decide per question
  let detected = [];
  for (let q=0;q<20;q++){
    let col = [answers[0][q]||0, answers[1][q]||0, answers[2][q]||0, answers[3][q]||0];
    let maxD = Math.max(...col), idxMax = col.indexOf(maxD);
    let fillThreshold = 0.16; // tuned for 3mm (may require real-photo tuning)
    if (maxD > fillThreshold){
      // ambiguous check
      let sorted = col.slice().sort((a,b)=>b-a);
      let ambiguous = (sorted[0] - sorted[1]) < 0.12;
      detected.push({selected:idxMax, densities:col, ambiguous:ambiguous});
    } else detected.push({selected:-1, densities:col, ambiguous:false});
  }

  // compare with key
  let correct=0; let details=[];
  for (let q=0;q<20;q++){
    let d = detected[q]; let sel = d.selected; let ca = (q<key.length)? key[q] : null;
    let densStr = d.densities.map(x=>x.toFixed(2)).join(',');
    if (sel === -1) details.push(`Q${q+1}: — não marcada | dens: [${densStr}]`);
    else {
      let letter = String.fromCharCode(65+sel);
      if (ca !== null && sel === ca){ correct++; details.push(`Q${q+1}: ${letter} ✅ | dens: [${densStr}]`); }
      else details.push(`Q${q+1}: ${letter} ❌ (correta=${String.fromCharCode(65+ca)}) | dens: [${densStr}]`);
    }
  }
  let score = Math.round((correct/20)*100);

  // cleanup some mats but return warped for preview (caller must delete)
  srcMat.delete(); srcTri.delete(); dstTri.delete(); M.delete();
  gray.delete(); blur.delete(); th.delete(); cnts.delete(); hier.delete();

  return {warp: warped, correct: correct, total:20, score: score, detail: details.join('\n')};
}

// display result in page
function displayResult(res){
  resultsArea.innerHTML = '';
  const card = document.createElement('div'); card.className='resultsCard';
  card.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center"><div><strong>Resultado</strong><div class="small">Acertos: ${res.correct}/${res.total} — ${res.score}%</div></div><div><button id="downloadBtn" style="padding:8px 10px;border-radius:8px;border:0;background:#2563eb;color:#fff">Baixar imagem recortada</button></div></div><div style="margin-top:8px"><canvas id="outCanvas" width="${res.warp.cols}" height="${res.warp.rows}" style="max-width:100%;border:1px solid #ddd;border-radius:6px"></canvas></div><div style="margin-top:8px"><pre>${res.detail}</pre></div>`;
  resultsArea.appendChild(card);
  const outCanvas = document.getElementById('outCanvas');
  cv.imshow(outCanvas, res.warp);
  // download button
  document.getElementById('downloadBtn').onclick = ()=>{
    const dataUrl = outCanvas.toDataURL('image/png');
    const a = document.createElement('a'); a.href = dataUrl; a.download = 'gabarito_recortado.png'; a.click();
  };
  // delete warp mat to avoid leaks
  res.warp.delete();
  log('Processamento finalizado.');
}

</script>
</body>
</html>
